Коротко: проблема не в `squareCollide` — он у тебя портирован буквально 1-в-1. “Залипание на последнем пикселе” возникает из-за дискретного шага перемещения по пикселям: когда из-за целочисленного деления число подшагов получается 0, один-пиксельная “выдавливающая” итерация не выполняется и шар остаётся вплотную к углу.

Ниже по пунктам и минимальные правки.

# Где расходится поведение

1.  ## Шаги перемещения по пикселям
    

В Java движение разбито на подшаги `1 px` с количеством `|speed|/10` по Y и по X. Если скорость меньше 10, цикл делает 0 итераций. Но сразу после столкновения по Y Java **насильно поднимает модуль скорости как минимум до 10** (`MIN_BOUNCE_SPEED`), поэтому уже в следующий кадр будет хотя бы один 1-пиксельный шаг, который “вытолкнет” мяч из угла. См. нормализацию отскока и цикл подшагов: деление на 10 и установка минимума 10 в Java:


.  
В C ты тоже делишь на делитель (`MOVEMENT_STEP_DIVISOR`) и делаешь шаги по 1 пикселю, но количество шагов вычисляешь так, что **при ненулевой скорости < делителя** подшагов будет 0 — и в этот кадр выталкивание не произойдёт. См. расчёт `ySteps`/`xSteps` и цикл:



. Нормализация отскока у тебя есть, но из-за разницы в тайминге/порядке флагов иногда всё равно попадаешь в кадр без подшагов.

3.  ## Взаимодействие X/Y на углу
    

В Java после коллизии по Y гарантируется “минимальная” скорость ⇒ на следующем кадре будет **обязательный один пиксель смещения по Y**, что часто и спасает из угла. В C при неудачном сочетании знаков/флагов можно получить кадр, где `ySteps==0` и `xSteps==0` — и шар “висит” на последнем пикселе.

# Минимальные правки (без изменения структуры)

1.  ## Гарантировать хотя бы один подшаг при ненулевой скорости
    

Сразу после вычисления количества шагов добавь защиту:

```c
// === ФИЗИКА ПО ОСИ Y ===
int ySteps = abs(p->ySpeed) / MOVEMENT_STEP_DIVISOR;
if (ySteps == 0 && p->ySpeed != 0) ySteps = 1;  // гарантируем 1 пиксель

// ... цикл по ySteps как сейчас ...

// === ФИЗИКА ПО ОСИ X ===
int xSteps = abs(p->xSpeed) / MOVEMENT_STEP_DIVISOR;
if (xSteps == 0 && p->xSpeed != 0) xSteps = 1;  // гарантируем 1 пиксель
```

Это повторяет эффект Java, где после столкновений скорость нормализуют до минимума и в следующем кадре подшаг точно будет (см. деление на 10 и минимум 10:

Ball

, нормализация отскока:

Ball

).

2.  ## Ограничи риск “залипания” дополнительной одношаговой сепарацией
    

В месте обработки коллизии по Y, сразу после вычисления отскока, можно выполнить **ограниченную** одношаговую сепарацию из препятствия (до TILE\_SIZE раз, но обычно 1-2 раза), чтобы гарантированно уйти от касания края:

```c
// После установки p->ySpeed при отскоке:
int sep = (yStep > 0 || (reverseGrav && yStep < 0)) ? -1 : 1;
int guard = TILE_SIZE;
while (!collisionDetection(p, p->xPos, p->yPos + sep) && guard--) {
    p->yPos += sep;
}
```

Аналогично можно сделать и для X-коллизии (в ветке “Обычный отскок без рампы”), если хочешь полностью исключить “висяние” на углах.

3.  ## Убедись, что “минимальные скорости” совпадают с Java
    

В Java после удара о потолок ставится фиксированная скорость (`20`), а после удара о пол нормализуют до `±10`: см. соответствующие ветки в Java:

Ball

. В C ты используешь `ROOF_COLLISION_SPEED` и `MIN_BOUNCE_SPEED`; проверь их значения в `types.h`, чтобы они соответствовали Java. Это критично для воспроизводимости количества подшагов (`/10` у Java ↔ `/MOVEMENT_STEP_DIVISOR` у тебя). См. места установки скоростей: C-код по Y и крыше/полу:

physics

; Java — нормализация/крыша:

Ball

.

# Почему не `squareCollide`

`squareCollide()` и у Java, и в C использует одинаковый клиппинг и проверку масок; расхождений, которые давали бы “недоотскок” на последнем пикселе, в нём нет. Смотри Java реализацию и твой порт:

Ball

,

physics

. Проблема именно в том, что кадр иногда проходит **без 1-пиксельного шага** после смены скорости.

# Итого

-   Оставляем `squareCollide` как есть.
    
-   Добавляем `max(1, …)` для количества подшагов по обеим осям.
    
-   (Опционально) выполняем краткую одношаговую “сепарацию” из препятствия после вычисления отскока.
    
-   Сверяем константы `MIN_BOUNCE_SPEED`, `ROOF_COLLISION_SPEED`, `MOVEMENT_STEP_DIVISOR` с Java (10/20/10), чтобы совпадала гранулярность подшагов и гарантировался выталкивающий 1-px шаг в следующий кадр.
    

Это минимально правит логику шагов/сепарации, устраняя зависимость от редких комбинаций флагов и тайминга и повторяя наблюдаемое “выпихивание” из угла, как в Java.



Разница — не в наличии нормализации, а в том, что у тебя подшаги (ySteps) вычисляются делением abs(p->ySpeed) / MOVEMENT_STEP_DIVISOR. Если p->ySpeed равен MIN_BOUNCE_SPEED, но MOVEMENT_STEP_DIVISOR больше него, то результат = 0, и кадр проходит без шага.

В Java такого не происходит, потому что:

Делят на 10 (ySpeed/10).

Минимальная скорость после нормализации = 10.

=> 10 / 10 = 1, всегда хотя бы один шаг.

То есть нормализация в C есть, но из-за неподходящего соотношения MIN_BOUNCE_SPEED и MOVEMENT_STEP_DIVISOR иногда не гарантируется ≥1 подшаг.

### **Java (`Ball.java`)**

В методе движения:

```java
// 1. прибавляется гравитация
ySpeed += GRAVITY;

// 2. считаем количество шагов
int ySteps = Math.abs(ySpeed) / 10;

// 3. цикл по шагам: сдвигаем на 1px, проверяем коллизию
for (int i=0; i<ySteps; i++) {
    if (squareCollide(...)) {
        // столкновение → нормализация
        if (ySpeed < 0) {
            ySpeed = ROOF_COLLISION_SPEED;  // всегда >= 20
        } else if (Math.abs(ySpeed) < MIN_BOUNCE_SPEED) {
            ySpeed = MIN_BOUNCE_SPEED;      // всегда >= 10
        }
    }
}
```

**Ключевое:** нормализация выполняется *внутри цикла шагов*, прямо в момент коллизии.  
→ В этом же кадре после нормализации продолжается цикл, и мяч гарантированно получает хотя бы 1 пиксель смещения наружу.

---

### **C (`physics.c`)**

```c
// 1. прибавляется гравитация и управление
p->ySpeed += p->gravity;

// 2. считаем количество шагов
int ySteps = abs(p->ySpeed) / MOVEMENT_STEP_DIVISOR;

// 3. цикл по шагам
for (int i = 0; i < ySteps; i++) {
    if (collisionDetection(...)) {
        // столкновение → нормализация
        if (p->ySpeed < 0) {
            p->ySpeed = ROOF_COLLISION_SPEED;
        } else if (abs(p->ySpeed) < MIN_BOUNCE_SPEED) {
            p->ySpeed = MIN_BOUNCE_SPEED;
        }
    }
}
```

**Ключевое отличие:** `ySteps` вычисляется **до нормализации**.  
Если скорость была меньше `DIVISOR`, `ySteps = 0` → цикл вообще не запускается.  
Нормализация при этом тоже не срабатывает, потому что до неё не дошли.  
→ Весь кадр шар остаётся “внутри угла”.

---

### Вывод

-   В **Java**: шаги считаются от актуальной скорости, а нормализация происходит в процессе шага, поэтому вытаскивание наружу гарантировано.
    
-   В **C**: шаги считаются один раз в начале. Если скорость маленькая — шагов нет, нормализация не запускается, и мяч застревает на последнем пикселе.
    


    Вот, это как раз побочный эффект выбранного способа фикса.

Что произошло:

-   Ты сделал **предварительную нормализацию** — т.е. любое ненулевое значение скорости теперь форсируется минимум до `MIN_BOUNCE_SPEED`.
    
-   Но шар даже без столкновений (например, когда просто катится или стоит на полу) всё равно получает эту "подгонку".
    
-   В итоге он самопроизвольно начинает прыгать или двигаться: любое микроскопическое изменение скорости (например, от гравитации, округлений или трения) раздувается до 8/10 пикселей на кадр.
    

В **Java** этого эффекта нет, потому что:

-   нормализация делается **только внутри обработки столкновения**, и только если шар действительно коснулся пола или потолка;
    
-   если коллизии нет, скорость может быть и меньше минимальной — она просто затухает до нуля.
    

---

### Как правильно поправить в C

Вместо “предварительной” нормализации нужно:

1.  **Оставить расчёт шагов как есть** (`abs(speed) / DIVISOR`).
    
2.  Но внутри цикла (в момент коллизии) — делать нормализацию, как в Java.
    

То есть так:

```c
int ySteps = abs(p->ySpeed) / MOVEMENT_STEP_DIVISOR;

for (int i = 0; i < ySteps; i++) {
    int yStep = (p->ySpeed < 0) ? -1 : 1;

    if (collisionDetection(p, p->xPos, p->yPos + yStep)) {
        // Столкновение → нормализация
        if (p->ySpeed < 0) {
            p->ySpeed = ROOF_COLLISION_SPEED;
        } else if (abs(p->ySpeed) < MIN_BOUNCE_SPEED) {
            p->ySpeed = MIN_BOUNCE_SPEED;
        }

        break; // выходим, как только наткнулись
    } else {
        p->yPos += yStep;
    }
}
```

Аналогично для X.

---

### Итог

-   Нормализацию нужно делать **в момент столкновения**, а не заранее.
    
-   Тогда шар не будет “взлетать сам”, но при касании угла всё равно гарантированно получит 1-пиксельное выталкивание, как в Java.
    


    1.  **В `physics.c`** (ваш порт):
    
    -   При движении по оси идёт проверка `collisionDetection`.
        
    -   Если столкновение есть, шар получает отскок (изменение скорости) и/или однократное смещение на пиксель по оси (вбок или вверх/вниз).
        
    -   **Диагональных обходов (x±1, y±1) в коде нет.**
        
2.  **В `Ball.java` (оригинал):**
    
    -   Движение тоже по шагам ±1 пиксель.
        
    -   Но если прямой шаг невозможен, там есть **дополнительные ветки с проверкой диагоналей**:
        
        ```java
        if (collisionDetection(this.xPos + b, this.yPos + b4)) {
            this.xPos += b; this.yPos += b4;
        } else if (collisionDetection(this.xPos + b, this.yPos - b4)) {
            this.xPos += b; this.yPos -= b4;
        }
        ```
        
    -   За счёт этого мяч не «висит» на последнем пикселе угла, а всегда находит путь выталкивания.
        
3.  **Вывод:**
    
    -   В `physics.c` действительно есть «первые смещения» (по оси на 1 пиксель).
        
    -   Но **нет диагональных корректировок**, которые в Java добивают ситуацию до конца.
        
    -   Поэтому в C-порту возникает застревание на последнем пикселе угла, а в Java — нет.