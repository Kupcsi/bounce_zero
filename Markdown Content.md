MAJOR | save.c:11 | Путь `#define SAVE_FILE_PATH "bounce_save.dat"` жёстко привязан к корень PSP  
Почему: на PSP сохранения обычно должны лежать в `ms0:/PSP/SAVEDATA/<ID>/`. Использование корня Memory Stick может не пройти сертификацию.
Предложение: перенести в стандартную директорию Savedata и использовать `sceIo*` API вместо stdio.


Я прошёлся по всем точкам, где код трогает PSP GU, собрал схему текущего пайплайна, выделил «дыры», а затем предложил новую, более оптимальную схему (Renderer 2.0) с пошаговым планом миграции.

---

# 1) Где и как мы используем PSP GU сейчас

## Узлы касания GU

-   **graphics.c** — центральная обёртка GU: init/shutdown, `graphics_clear`, `graphics_begin_plain/textured`, батчинг спрайтов, `graphics_flush_batch`, текст/прямоугольники.
    
-   **png.c** — загрузка текстур в VRAM: подготовка POT размеров, `sceGuTexImage`, управление форматами/фильтрами/WRAP (часть параметров выставляется при каждом биндинге).
    
-   **level.c** — «толстый» клиент отрисовки: много переключений `plain/textured`, спец-рендер тайлов (EXIT, движущиеся шипы), очередь foreground колец (ring FG queue).
    
-   **menu.c / game.c** — высокоуровневые сцены/HUD: частые переходы между режимами, вызовы измерения/отрисовки текста, многократные мелкие спрайты (жизни/кольца).
    
-   **font9.c/h** (косвенно через `graphics_draw_text*`) — посимвольная отрисовка.
    

## Типичный кадр (по факту)

1.  `graphics_clear()` → сброс scissor на fullscreen (побочный эффект).
    
2.  Отрисовка мира: `level_render_visible_area()`:
    
    -   старт в textured;
        
    -   для фона/воды — переключение в plain → `graphics_draw_rect` → обратно в textured;
        
    -   спец-тайлы (EXIT, spikes) — локальные свитчи режимов; часть спрайтов через xform;
        
    -   добавление передних частей колец в очередь → `level_flush_ring_foreground()` позже.
        
3.  Игрок/спрайты → textured batch; местами принудительные `flush`.
    
4.  HUD/текст: снова plain (прямоугольники), затем textured (иконки), затем plain (текст).
    
5.  `graphics_end_frame()` → `flush` и завершение списка команд.
    

## Узкие места/«дыры»

-   **A. Тогглы режимов plain↔textured в циклах отрисовки** (особенно в `level.c`): лишние state changes.
    
-   **B. Сайд-эффекты состояния**:
    
    -   `graphics_clear()` меняет scissor глобально.
        
    -   `graphics_begin_textured()` сбрасывает цвет в белый.
        
-   **C. Текстуры**:
    
    -   Повторная установка TexFunc/Filter/Wrap/Scale/Offset при каждом биндинге.
        
    -   Страйд = width по умолчанию; отсутствует явная поддержка pitch.
        
    -   VRAM-аллокатор без выравнивания 16 байт.
        
-   **D. Батчинг**:
    
    -   Нет жёсткой защиты от переполнения `MAX_SPRITES_PER_BATCH`.
        
    -   HUD/текст/мелкие иконки рисуются многими мелкими вызовами.
        
-   **E. Текст**:
    
    -   Посимвольная отрисовка с частыми переключениями пайплайна.
        
    -   Нет «глиф-батчинга»; метрики частично есть, но не используются для группировки.
        
-   **F. Матрицы/проекции**:
    
    -   Режим 2D используется, но ортографическая матрица не закреплена как жёсткий инвариант кадра (в ряде мест полагаемся на состояние по умолчанию).
        
-   **G. Порядок/синхронизация**:
    
    -   Смешанный `flush` внутри begin\_\* и в конце кадра; протокол не документирован.
        
-   **H. Ресурсы**:
    
    -   `png_free_texture` обнуляет только `data`.
        
    -   `local_get_text` — `malloc` на каждый вызов, нет политики владения.
        

> Примечание по источникам best practices: ниже я привожу стандартную для PSPSDK схему (ортографическая проекция, единый текстурный батч, 16-байтовые выравнивания, кэш состояния). Я не ссылаюсь на внешние материалы из-за отсутствия онлайна; при необходимости могу сопоставить с sample’ами PSPSDK (gu/sprite, gu/tex, gu/ortho) при доступе к ним.

---

# 2) Целевая схема рендера (Renderer 2.0)

## Ключевые принципы

1.  **Один доминирующий пайплайн = textured only.**  
    Заменить все `plain`\-прямоугольники на отрисовку 1×1 белой текстуры с цветом через `sceGuColor`. Это резко сокращает переключения режимов (texture on/off).
    
2.  **StateCache:** тонкий кэш состояния GU:
    
    -   текущая текстура, TexFunc/Filter/Wrap/Scale/Offset;
        
    -   текущий цвет, альфа-блендинг, scissor;
        
    -   флаги (TEXTURE\_2D включён/выключен).  
        Все вызовы `sceGu*` проходят через кэш и вызываются только при изменении.
        
3.  **Batcher с защитой от переполнения:**
    
    -   фиксированный динамический VBO в RAM (двойная буферизация) под N спрайтов;
        
    -   при достижении лимита — автоматический `flush()` и продолжение;
        
    -   сортировка по «ключу материала» (texture id + shader state) на уровне API, чтобы минимизировать биндинги.
        
4.  **Ортографическая 2D матрица один раз в кадр:**  
    В `begin_frame()` выставлять:
    
    -   `sceGuMatrixMode(GU_PROJECTION);` орто 0..480 / 0..272;
        
    -   `sceGuDisable(GU_DEPTH_TEST); sceGuDisable(GU_LIGHTING);` и пр.
        
5.  **Scissor-stack** (пользовательский):  
    `graphics_push_scissor()/pop_scissor()` внутри `graphics.c`, без глобальных сюрпризов.
    
6.  **Текст как частный случай спрайтов:**
    
    -   предсобранный атлас глифов (font9 уже по сути такой);
        
    -   `text_submit(glyph_quads)` добавляет все символы в один батч, **без** смены режима.
        
7.  **VRAM менеджер с выравниванием 16 байт и pitch:**
    
    -   хранить `actual_width/height` и `stride` в `texture_t`;
        
    -   `sceGuTexImage(level, width, height, stride, data)` — заполнять корректно.
        
8.  **Явный протокол кадра:**
    
    -   `graphics_begin_frame(clearColor)` → `submit world` → `submit sprites` → `submit UI/text` → `graphics_end_frame()`.  
        Никаких `sceGuEnable/Disable` извне.
        

## Схема API (вкратце)

```c
// graphics.h
void graphics_begin_frame(u32 clear_abgr);
void graphics_end_frame(void);

void graphics_set_scissor(int x0, int y0, int x1, int y1);
void graphics_push_scissor(int x0,int y0,int x1,int y1);
void graphics_pop_scissor(void);

void graphics_bind_texture(texture_t* tex); // через StateCache

// Универсальный «прямоугольник» (цветной/текстурный)
void graphics_submit_quad(float x, float y, float w, float h,
                          float u0, float v0, float u1, float v1,
                          u32 color);

// Текст
void text_draw(const char* s, float x, float y, float scale, u32 color);
```

## Псевдокод кадра

```c
graphics_begin_frame(BACKGROUND_COLOUR);

// Мир (тайлы) — отсортировано по текстурам атласа:
graphics_bind_texture(tileset);
level_submit_visible_area(cameraX, cameraY); // только submit_quad'ы
graphics_flush(); // если нужно

// Игрок, кольца (FG):
graphics_bind_texture(tileset);
submit_ball_and_fg(); // всё батчится
graphics_flush();

// HUD + текст (тот же пайплайн, уже textured):
submit_ui_quads(); // белая текстура + цвета
text_draw(score_text, ...);

graphics_end_frame();
```

---

# 3) Конкретные оптимизации по файлам

## graphics.c / graphics.h

-   **Убрать `begin_plain()` вообще.** Оставить только textured, завести **белую 1×1 текстуру** в VRAM в init. Любые прямоугольники рисовать ею.
    
-   **StateCache:** кешировать:
    
    -   текущий `texture_t*`;
        
    -   `TexFunc/Filter/Wrap/Scale/Offset` (заводим битовую маску «грязности»);
        
    -   `color` и `alpha` (если используется);
        
    -   `scissor`.
        
-   **Scissor-stack:** локально хранить последний scissor и стек (маленький, 8 уровней достаточно).
    
-   **Batcher:**
    
    -   кольцевой буфер вершин (минимум на 512–1024 спрайта), double-buffered;
        
    -   при `count == capacity` → `flush`.
        
-   **Контракт:** в `graphics.h` документировать протокол кадра и запрет прямых `sceGu*` вне graphics.c.
    

## png.c / texture\_t

-   Добавить `stride` и заполнять `sceGuTexImage` корректно (учитывая POT расширение).
    
-   VRAM-аллокатор: выравнивать адрес и размер **до 16 байт**.
    
-   `png_free_texture`: `memset(tex, 0, sizeof(*tex))`.
    

## level.c

-   **Отрисовка**: вместо немедленного рисования — **submit**:
    
    -   фон/вода → белая текстура + цвет;
        
    -   спрайты → тот же батч, не переключая режимы;
        
    -   ring FG queue остаётся, но она тоже «submit», без смены состояния.
        
-   **Минимизировать «if (graphics\_get\_texturing\_state())** — он исчезнет.
    
-   **EXIT/шипы**: клиппинг сделать на уровне UV/вершин, без режима plain.
    
-   **Сортировка**: необязательно глобально; локально держимся одной текстуры (атласа).
    

## menu.c / game.c / HUD

-   Все панели/полосы/строки — через белую текстуру + цвет, одним батчем.
    
-   Иконки/жизни/кольца — группой спрайтов, **без** промежуточных flush.
    

## font9.c/h, текст

-   Построить таблицу UV для глифов один раз; `text_draw()` пробегает строку, добавляет N спрайтов в текущий батч, **один bind** шрифта.
    
-   Для измерения текста использовать предрасчитанные advance-ы; кернинг (если нужен) — таблицей.
    

## input.c / save.c / прочее (по GU — вторично)

-   Не влияет на GU напрямую; оставить.
    

---

# 4) Что даст переход на Renderer 2.0

-   На типичном кадре число переключений режимов сократится с десятков до **0–2** (смена текстуры атласа/шрифта).
    
-   GU-вызовы сконцентрируются в `graphics_flush()` (один `sceGuDrawArray` на десятки/сотни спрайтов).
    
-   Прямоугольники/фон/полосы HUD станут «бесплатными» в плане состояния — это те же текстурные квады.
    
-   Текст перестанет «дергать» режим/цвет — один батч → одна текстура шрифта.
    
-   Пропадут скрытые побочные эффекты (`scissor`, принудительный белый цвет, и пр.).
    

---

# 5) Пошаговый план миграции (без риска)

1.  **Инфраструктура**
    
    -   В `graphics_init()` создать белую 1×1 текстуру в VRAM.
        
    -   Ввести StateCache и заменить прямые `sceGu*` внутри graphics.c на обёртки с кэшем.
        
    -   Добавить scissor-stack, но пока не использовать широко.
        
2.  **Отказ от plain-режима**
    
    -   Переписать `graphics_draw_rect()` на textured-квад c белой текстурой.
        
    -   Удалить `graphics_begin_plain()` и все его использования (оставить пустышкой на переходный период → no-op).
        
3.  **Батчер**
    
    -   Включить защиту от переполнения; собрать HUD/текст через массовый submit без промежуточного flush.
        
4.  **level.c**
    
    -   Перевести фон/воду/EXIT/шипы на submit-квады (без переключений), ring FG queue оставить, но выводить её тем же батчером.
        
    -   Удалить проверки `graphics_get_texturing_state()`.
        
5.  **Текст**
    
    -   `text_draw()` — один bind шрифта → батч всех глифов.
        
6.  **Чистка**
    
    -   Удалить лишние GU-вызовы, сбросы цвета, глобальную правку scissor внутри `graphics_clear()` (использовать scissor-stack локально, где нужно).
        

---

# 6) Быстрые выигрыши за день

-   Ввести белую 1×1 текстуру и заменить все прямоугольники на textured-квад → минус все переключения plain/textured.
    
-   Включить проверку переполнения батчера и автоматический `flush`.
    
-   Кэшировать `sceGuTex*` параметры при `graphics_bind_texture`.
    
-   В `png.c` выровнять VRAM-выделения на 16 байт.
    
-   `png_free_texture()` — `memset 0`.
    
-   `graphics_clear()` — убрать изменение scissor; добавить явный `graphics_set_scissor_fullscreen()` в начале кадра.
    

---

Если хотите, могу подготовить патч-набросок для `graphics.c/h` (StateCache + белая текстура + новый `graphics_draw_rect()` и батчер с защитой) — строго с минимальными правками внешнего API.

Вы правы: **сейчас текст рисуется попиксельно** — для каждого «зажжённого» бита глифа вызывается `graphics_draw_rect(...)`. Это видно в `graphics_draw_text_scaled`: циклы по `row/col` + `if (glyph->row[row] & ...) { graphics_draw_rect(...) }`

graphics

. Отсюда и лавина draw-вызовов, и срывы кадра при большом количестве строк. Ниже — подробная дорожная карта миграции на нормальный, быстрый «батч-текст» через атлас + единый textured-пайплайн.

---

# Цель

Убрать попиксельную отрисовку и постоянные переключения plain↔textured; перейти на:

-   единственный **textured-пайплайн** (прямоугольники тоже отрисовывать белой 1×1 текстурой);
    
-   **текст через атлас глифов** (1 quad = 1 буква), батч одной командой на строку/весь экран.
    

---

# Где мы сейчас теряем производительность

1.  Текст: `graphics_draw_text_scaled` делает сотни/тысячи вызовов `graphics_draw_rect` на строку, т.к. каждый пиксель глифа — отдельный quad. Это прямой источник «8 строк ок, 12 — срыв»
    
    graphics
    
    .
    
2.  Прямоугольники/HUD: много вызовов `graphics_draw_rect` и явные переключения на `graphics_begin_plain()` в UI/меню, затем обратно на текстуры .
    
3.  Спрайты PNG: местами рисуются в обход батчера (`graphics_flush_batch(); ... sceGuDrawArray(...)`), что дробит GU-список команд
    
    png
    
    .
    

---

# Пошаговая миграция

## Шаг 1. Единый textured-пайплайн (замена plain)

-   В `graphics_init()` создать **белую 1×1 RGBA-текстуру** в VRAM.
    
-   Переписать `graphics_draw_rect(...)` на отрисовку textured-квада этой текстурой, цвет задаётся через `sceGuColor`, без `sceGuDisable/Enable(GU_TEXTURE_2D)`.
    
-   Удалить из пользовательского кода вызовы `graphics_begin_plain()`; прямоугольники в меню/игре (в т.ч. подложки, панели) будут тем же батчем, что и спрайты/текст (сразу устраняется «дёргание» состояния, например в `menu.c`/`game_over_render`) .
    

**Эффект:** никакой plain, меньше state-changes, все прямоугольники батчатся вместе со спрайтами.

## Шаг 2. Собрать **атлас шрифта** из `font9`

-   Сейчас `font9` — битовые глифы 9×(width) в массивах строк (битмаски) .
    
-   В `graphics_init()` (или `font_init()`) один раз:
    
    -   Сгенерировать в RAM RGBA-изображение-атлас (POT размер, например 256×128), где для каждого глифа разложить биты: `alpha = 255` для «1», `0` для «0», RGB = 255 (белый).
        
    -   Загрузить в VRAM через существующий путь (по аналогии с PNG) и сохранить `texture_t` + таблицу UV-координат для каждого символа.
        
    -   Запомнить `advance` = `glyph->width + FONT9_SPACING` (как сейчас считает `graphics_measure_text`)
        
        graphics
        
        .
        

**Замечание:** это делается 1 раз при старте; в рантайме мы больше **никогда** не «рисуем пиксели» поштучно.

## Шаг 3. Батчер текста (строка/кадр = один draw)

-   В `graphics.c` завести общий **батч спрайтов** (если его ещё нет), с защитой от переполнения.
    
-   Добавить API уровня `graphics_text_begin(fontTex)`, `graphics_text_submit(str, x, y, color, scale)`, `graphics_text_flush()`.
    
-   Внутри `graphics_text_submit(...)`:
    
    -   `graphics_bind_texture(fontTex)` **ровно один раз**;
        
    -   для каждого символа строки — добавить **один quad** с нужными UV в общий массив вершин; **не** вызывать `sceGuDrawArray` на символ.
        
-   В конце UI/меню — **один** `graphics_text_flush()` (или общий `graphics_flush_batch()`).
    

**Эффект:** 12 строк текста → 1–2 draw-вызова вместо сотен/тысяч.

## Шаг 4. Подмена текущих вызовов

-   Заменить `graphics_draw_text_scaled(...)` так, чтобы он **не** делал «попиксельные прямоугольники», а использовал батч и атлас. Сигнатура и поведение для вызывающего кода остаются прежними (минимальные правки внешнего API)
    
    graphics
    
    .
    
-   Там, где раньше был `graphics_begin_plain()` перед текстом/панелями, — удалить (всё textured). Примеры: `high_score_render`, `game_over_render` .
    
-   В PNG-отрисовке убрать принудительные локальные `flush` там, где можно — вместо `graphics_flush_batch(); graphics_begin_textured(); graphics_bind_texture(tex); ... sceGuDrawArray(...)` перевести на единый батч (не дробить список)
    
    png
    
    .
    

## Шаг 5. Стейт-кэш GU

-   Внутри `graphics.c` ввести кэш текущих состояний: привязанная текстура, TexFunc/Filter/Wrap, текущий цвет, scissor и т. п.
    
-   Любой `sceGu*` вызывается **только при изменении** (особенно важно для `graphics_bind_texture(...)`, которое сейчас переинициализирует стейты чаще, чем нужно). Это «микрооптимизация», но на PSP эффект заметен.
    

## Шаг 6. Протокол кадра

-   Зафиксировать в `graphics.h`:
    
    -   `graphics_begin_frame(clearColor)` → отрисовка мира/спрайтов/UI/текста (всё textured) → `graphics_end_frame()`.
        
    -   Внешнему коду **запрещены** прямые `sceGuEnable/Disable` — только через `graphics.*`.
        
-   Убрать скрытые побочные эффекты (`graphics_clear()` больше не сбрасывает scissor на весь экран без явного запроса).
    

---

# Риски и как их закрыть

-   **Размер атласа (POT):** подберите размеры с учётом всех 194 символов `font9`; проконтролируйте `stride` и формат при `sceGuTexImage`. Если нужно — держите `stride` в `texture_t` (сейчас stride = width, это не всегда универсально)
    
    png
    
    .
    
-   **Переполнение батча:** добавить авто-`flush` при достижении лимита. Это снимет «12 строк ломает» окончательно.
    
-   **Совместимость цвета:** `sceGuTexFunc(GU_TFX_MODULATE, GU_TCC_RGBA)` и белый атлас → цвет управляется `sceGuColor`.
    
-   **Сохранить масштабирование:** `scale` учитывается в размерах quad (w = glyphW*scale, h = glyphH*scale), расчёт ширины текста (`graphics_measure_text`) можно оставить прежним (в основе — суммарный advance)
    
    graphics
    
    .
    

---

# Что поменяется для вызывающего кода

Ничего принципиального: вы как и прежде вызываете `graphics_draw_text(...)` / `graphics_draw_text_scaled(...)`. Внутри они больше **не** генерируют тысячи `graphics_draw_rect`, а лишь добавляют квады в батч и рисуют их одной командой. Прямоугольники/панели в меню и HUD так же уходят в общий textured-батч вместо plain-режима — см. места, где сейчас стоят `graphics_begin_plain()` и прямоугольники в `menu.c`/`game_over_render` .

---

# Минимальный MVP (1–2 дня работ)

1.  Белая 1×1 текстура + переписанный `graphics_draw_rect` (textured).
    
2.  Генерация атласа из `font9` при старте и хранение UV на символ.
    
3.  Новый `graphics_draw_text_scaled` → батчирует строку и рисует одним вызовом.
    
4.  Удаление `graphics_begin_plain()` из меню/игры и замена на textured-отрисовку.
    

Далее — «косметика» (стейт-кэш, чистка принудительных `flush`, выравнивание VRAM и stride в `png.c`) — без изменения публичного API.

Если хотите, отмечу конкретные участки для правки «по строкам» в каждом файле и порядок коммитов (чтобы сборка не падала на промежуточных шагах).

Да, такие места есть — вы их, возможно, не замечаете, потому что «оно работает». Но с точки зрения **качества кода и эффективности на PSP** (и вообще C-кода) я при просмотре видел несколько категорий «лишнего» или «подозрительно обёрточного».


















---

## 1\. Избыточные обёртки GU

-   **`graphics_begin_plain()` / `graphics_begin_textured()`**  
    Смысла держать их нет — это просто вызовы `sceGuDisable/Enable(GU_TEXTURE_2D)` и сброс цвета. Они плодят лишние переходы состояний и ещё скрыто меняют state. В новой схеме (всё через textured + белая текстура) их можно выбросить.  
    ➝ Это классический пример «обёртки ради обёртки».
    
-   **`graphics_get_texturing_state()`**  
    Держится ради `if(...)` в `level.c`, чтобы узнать, plain ли сейчас. При новой архитектуре (всегда textured) — бесполезно, всё равно всегда `true`.
    

---

## 2\. Лишние проверки / hop’ы

-   **`graphics_clear()`**  
    Делает и `sceGuClear`, и заодно сбрасывает scissor в fullscreen. Это скрытая «магия». Лучше разнести: `graphics_clear(color)` (только очистка), `graphics_set_scissor_fullscreen()` (явно).
    
-   **`local_get_text()`**  
    Возвращает `malloc`\-строку всегда. В итоге приходится либо `free`, либо протекает память. Это типичный «лишний hop» (обёртка вместо простого возврата `const char*`). На PSP динамические аллокации вообще нежелательны в рантайме.
    

---

## 3\. Избыточные функции / дублирование логики

---

## 4\. Подозрительные «hop»-ы в батчере

-   В `graphics_flush_batch()` вы гоняете все накопленные спрайты в GE. Но при смене текстуры/цвета HUD вы иногда делаете `flush` руками (например, в `png.c`) и тут же снова начинаете batch. Это «лишний hop» — сбросить и перезапустить, хотя можно держать всё в одном списке.
    

---

## 5\. «Велосипеды» вместо SDK

-   **Сохранения (`save.c`)** — пишутся через `fopen/fwrite/fclose`. На PSP лучше через `sceIoOpen/sceIoWrite` (меньше hop’ов, меньше прослоек, надёжнее).
    
-   **Ввод (`input.c`)** — жёстко в digital-mode. PSP SDK даёт и аналоговый, можно читать напрямую, без лишней конверсии через `old_pad`.

























































 

---

## Как оптимизировать архитектурно

1.  **Убрать «plain/textured» слой** — он только плодит вызовы. Всё textured.
    
2.  **Свести «text через rect» к «text через quads из атласа»**.
    
3.  **Заменить обёртки-обёртки (`arith_shift1`, malloc в локализации, file\_open\_with\_fallback)** на прямые вызовы или статические таблицы.
    
4.  **Оставить только одну точку контроля GU** (graphics.c). Всё остальное — только submit данных.


























## Анализ функций-прокладок в graphics.c

**Обнаружены избыточные функции-прокладки:**

### graphics_get_texturing_state()
```c
int graphics_get_texturing_state(void) {
    return s_texturing_enabled; // просто возврат переменной
}
```
- **Проблема:** чистая прокладка, возвращает глобальную переменную
- **Использование:** 1 раз в level.c
- **Решение:** заменить прямым доступом к переменной или убрать

### graphics_begin_textured()
```c
void graphics_begin_textured(void) {
    graphics_set_texturing(1);
    sceGuTexFunc(GU_TFX_REPLACE, GU_TCC_RGBA);
}
```
- **Проблема:** тонкая обёртка, используется 14 раз
- **Решение:** можно заменить прямыми вызовами в критических местах

### graphics_begin_plain()
```c
void graphics_begin_plain(void) {
    graphics_flush_batch();
    graphics_set_texturing(0);
}
```
- **Проблема:** добавляет лишний хоп, используется 11 раз
- **Решение:** можно заменить прямыми вызовами

**Вывод:** graphics_set_texturing() уже обеспечивает кэширование состояния. Остальные функции добавляют ненужные слои абстракции без существенной пользы.